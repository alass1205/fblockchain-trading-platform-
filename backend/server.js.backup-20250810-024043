const express = require('express');
const cors = require('cors');
const multer = require('multer');
const sqlite3 = require('sqlite3').verbose();
const ethers = require('ethers');
const fs = require('fs');
const path = require('path');

const app = express();
const PORT = process.env.PORT || 3001;

// Configuration multer pour upload de fichiers
const storage = multer.diskStorage({
    destination: function (req, file, cb) {
        cb(null, 'uploads/');
    },
    filename: function (req, file, cb) {
        cb(null, Date.now() + '-' + file.originalname);
    }
});

const upload = multer({ 
    storage: storage,
    limits: { fileSize: 5 * 1024 * 1024 } // 5MB max
});

// Middleware
app.use(cors());
app.use(express.json());
app.use('/uploads', express.static('uploads'));

// Cr√©er le dossier uploads s'il n'existe pas
if (!fs.existsSync('uploads')) {
    fs.mkdirSync('uploads');
}

// Initialisation de la base de donn√©es
const db = new sqlite3.Database('trading.db');

// Cr√©ation des tables
db.serialize(() => {
    // Table des actifs
    db.run(`CREATE TABLE IF NOT EXISTS assets (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        symbol TEXT UNIQUE,
        name TEXT,
        type TEXT,
        contract_address TEXT,
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP
    )`);

    // Table des utilisateurs
    db.run(`CREATE TABLE IF NOT EXISTS users (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        wallet_address TEXT UNIQUE,
        legal_name TEXT,
        passport_picture TEXT,
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP
    )`);

    // Table des ordres
    db.run(`CREATE TABLE IF NOT EXISTS orders (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        user_address TEXT,
        asset_symbol TEXT,
        order_type TEXT,
        quantity REAL,
        price REAL,
        status TEXT DEFAULT 'pending',
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP
    )`);

    // Table de l'historique des prix
    db.run(`CREATE TABLE IF NOT EXISTS price_history (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        asset_symbol TEXT,
        price REAL,
        timestamp DATETIME DEFAULT CURRENT_TIMESTAMP
    )`);

    console.log('‚úÖ Base de donn√©es initialis√©e');
});

// Routes API

// Test de l'API
app.get('/api/test', (req, res) => {
    res.json({ 
        message: 'API Backend fonctionne !',
        timestamp: new Date().toISOString(),
        port: PORT
    });
});

// Inscription utilisateur
app.post('/api/register', upload.single('passport'), (req, res) => {
    const { walletAddress, legalName } = req.body;
    const passportPicture = req.file ? req.file.filename : null;

    db.run(
        `INSERT OR REPLACE INTO users (wallet_address, legal_name, passport_picture) VALUES (?, ?, ?)`,
        [walletAddress, legalName, passportPicture],
        function(err) {
            if (err) {
                console.error('Erreur inscription:', err);
                res.status(500).json({ success: false, error: err.message });
            } else {
                res.json({ 
                    success: true, 
                    message: 'Utilisateur enregistr√©',
                    userId: this.lastID 
                });
            }
        }
    );
});

// Obtenir les informations utilisateur
app.get('/api/user/:address', (req, res) => {
    const address = req.params.address;
    
    db.get(
        `SELECT * FROM users WHERE wallet_address = ?`,
        [address],
        (err, row) => {
            if (err) {
                res.status(500).json({ success: false, error: err.message });
            } else {
                res.json({ success: true, user: row });
            }
        }
    );
});

// Obtenir les balances blockchain
app.get('/api/balances/:address', async (req, res) => {
    const userAddress = req.params.address;
    
    try {
        console.log('üìä R√©cup√©ration balances pour:', userAddress);
        
        // Configuration ethers.js
        const provider = new ethers.providers.JsonRpcProvider("http://localhost:8545");
        
        // Charger les adresses des contrats
        const addressesPath = path.join(__dirname, '../contracts/deployed-addresses.json');
        const addresses = JSON.parse(fs.readFileSync(addressesPath, 'utf8'));
        // Fallback global VAULT -> TradingVault
        if (!addresses.VAULT && addresses.VAULT) {
            addresses.VAULT = addresses.VAULT;
        }
        console.log("üîç DEBUG - Fichier charg√©:", addressesPath);
        console.log("üìã DEBUG - Contenu addresses:", addresses);
        console.log("üîç DEBUG - TRG:", addresses.TRG);
        console.log("üîç DEBUG - CLV:", addresses.CLV);
        console.log("üîç DEBUG - TradingVault:", addresses.VAULT);
        if (!addresses.VAULT && addresses.VAULT) {
            addresses.VAULT = addresses.VAULT;
            console.log("üîÑ Fallback: VAULT -> TradingVault:", addresses.VAULT);
        }
        
        // Charger les ABIs
        const tokenABI = JSON.parse(fs.readFileSync(path.join(__dirname, '../contracts/artifacts/contracts/StableCoin.sol/StableCoin.json'), 'utf8')).abi;
        const bondABI = JSON.parse(fs.readFileSync(path.join(__dirname, '../contracts/artifacts/contracts/BondToken.sol/BondToken.json'), 'utf8')).abi;
        const vaultABI = JSON.parse(fs.readFileSync(path.join(__dirname, '../contracts/artifacts/contracts/TradingVault.sol/TradingVault.json'), 'utf8')).abi;
        
        // Cr√©er les instances de contrats
        console.log("üîß DEBUG - Cr√©ation contrat TRG avec adresse:", addresses.TRG);
        console.log("üîß DEBUG - Cr√©ation contrat CLV avec adresse:", addresses.CLV);
        console.log("üîß DEBUG - Cr√©ation contrat vault avec adresse:", addresses.VAULT);
        const trgToken = new ethers.Contract(addresses.TRG, tokenABI, provider);
        const clvToken = new ethers.Contract(addresses.CLV, tokenABI, provider);
        const rooToken = new ethers.Contract(addresses.ROO, tokenABI, provider);
        const govToken = new ethers.Contract(addresses.GOV, bondABI, provider);
        const vault = new ethers.Contract(addresses.VAULT, vaultABI, provider);
        
        // R√©cup√©rer les balances wallet
        const trgBalance = await trgToken.balanceOf(userAddress);
        const clvBalance = await clvToken.balanceOf(userAddress);
        const rooBalance = await rooToken.balanceOf(userAddress);
        const govBonds = await govToken.getBondsByOwner(userAddress);
        
        // R√©cup√©rer les balances vault
        const trgVaultBalance = await vault.getBalance(addresses.TRG, userAddress);
        const clvVaultBalance = await vault.getBalance(addresses.CLV, userAddress);
        const rooVaultBalance = await vault.getBalance(addresses.ROO, userAddress);
        
        const balances = {
            TRG: ethers.utils.formatUnits(trgBalance, 18),
            CLV: ethers.utils.formatUnits(clvBalance, 18),
            ROO: ethers.utils.formatUnits(rooBalance, 18),
            GOV: govBonds.length.toString()
        };
        
        const vaultBalances = {
            TRG: ethers.utils.formatUnits(trgVaultBalance, 18),
            CLV: ethers.utils.formatUnits(clvVaultBalance, 18),
            ROO: ethers.utils.formatUnits(rooVaultBalance, 18)
        };
        
        console.log('‚úÖ Balances r√©cup√©r√©es:', balances);
        
        res.json({
            success: true,
            balances: balances,
            vaultBalances: vaultBalances
        });
        
    } catch (error) {
        console.error('‚ùå Erreur r√©cup√©ration balances:', error);
        res.status(500).json({
            success: false,
            error: error.message
        });
    }
});

// Cr√©er un ordre
app.post('/api/orders', (req, res) => {
    const { userAddress, assetSymbol, orderType, quantity, price } = req.body;
    
    db.run(
        `INSERT INTO orders (user_address, asset_symbol, order_type, quantity, price) VALUES (?, ?, ?, ?, ?)`,
        [userAddress, assetSymbol, orderType, quantity, price],
        function(err) {
            if (err) {
                console.error('Erreur cr√©ation ordre:', err);
                res.status(500).json({ success: false, error: err.message });
            } else {
                console.log('‚úÖ Ordre cr√©√©:', { id: this.lastID, userAddress, assetSymbol, orderType, quantity, price });
                res.json({ 
                    success: true, 
                    orderId: this.lastID,
                    message: 'Ordre cr√©√© avec succ√®s'
                });
            }
        }
    );
});

// Obtenir les ordres d'un utilisateur
app.get('/api/orders/:address', (req, res) => {
    const address = req.params.address;
    
    db.all(
        `SELECT * FROM orders WHERE user_address = ? ORDER BY created_at DESC`,
        [address],
        (err, rows) => {
            if (err) {
                res.status(500).json({ success: false, error: err.message });
            } else {
                res.json({ success: true, orders: rows });
            }
        }
    );
});

// Obtenir tous les ordres pour un actif
app.get('/api/orders/asset/:symbol', (req, res) => {
    const symbol = req.params.symbol;
    
    db.all(
        `SELECT * FROM orders WHERE asset_symbol = ? AND status = 'pending' ORDER BY price ASC`,
        [symbol],
        (err, rows) => {
            if (err) {
                res.status(500).json({ success: false, error: err.message });
            } else {
                res.json({ success: true, orders: rows });
            }
        }
    );
});

// Annuler un ordre
app.post('/api/orders/:id/cancel', (req, res) => {
    const orderId = req.params.id;
    
    db.run(
        `UPDATE orders SET status = 'cancelled' WHERE id = ?`,
        [orderId],
        function(err) {
            if (err) {
                res.status(500).json({ success: false, error: err.message });
            } else {
                res.json({ success: true, message: 'Ordre annul√©' });
            }
        }
    );
});

// Route pour ex√©cuter un trade R√âEL sur blockchain
app.post("/api/execute-trade", async (req, res) => {
    const { buyerAddress, sellerAddress, assetSymbol, quantity, price } = req.body;
    
    try {
        console.log("üîó Ex√©cution trade blockchain R√âELLE:", { buyerAddress, sellerAddress, assetSymbol, quantity, price });
        
        // Configuration ethers.js
        const provider = new ethers.providers.JsonRpcProvider("http://localhost:8545");
        const deployerPrivateKey = "0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80";
        const wallet = new ethers.Wallet(deployerPrivateKey, provider);
        
        // Charger les adresses des contrats
        const addressesPath = path.join(__dirname, '../contracts/deployed-addresses.json');
        const addresses = JSON.parse(fs.readFileSync(addressesPath, 'utf8'));
        // Fallback global VAULT -> TradingVault
        if (!addresses.VAULT && addresses.VAULT) {
            addresses.VAULT = addresses.VAULT;
        }
        console.log("üîç DEBUG - Fichier charg√©:", addressesPath);
        console.log("üìã DEBUG - Contenu addresses:", addresses);
        console.log("üîç DEBUG - TRG:", addresses.TRG);
        console.log("üîç DEBUG - CLV:", addresses.CLV);
        console.log("üîç DEBUG - TradingVault:", addresses.VAULT);
        if (!addresses.VAULT && addresses.VAULT) {
            addresses.VAULT = addresses.VAULT;
            console.log("üîÑ Fallback: VAULT -> TradingVault:", addresses.VAULT);
        }
        
        // Charger les contrats
        const vaultABI = JSON.parse(fs.readFileSync(path.join(__dirname, '../contracts/artifacts/contracts/TradingVault.sol/TradingVault.json'), 'utf8')).abi;
        
        const vault = new ethers.Contract(addresses.VAULT, vaultABI, wallet);
        
        console.log("üìã Ex√©cution du trade sur la blockchain...");
        
        // Charger l'ABI des tokens
        const tokenABI = JSON.parse(fs.readFileSync(path.join(__dirname, "../contracts/artifacts/contracts/StableCoin.sol/StableCoin.json"), "utf8")).abi;
        
        // 1. Transf√©rer l'asset du vendeur vers l'acheteur (wallet direct)
        const assetToken = new ethers.Contract(addresses[assetSymbol], tokenABI, wallet);
        const transferAssetTx = await assetToken.transferFrom(
            sellerAddress,
            buyerAddress,
            ethers.utils.parseUnits(quantity.toString(), 18)
        );
        await transferAssetTx.wait();
        console.log("‚úÖ Asset transf√©r√© (wallet-to-wallet):", transferAssetTx.hash);
        
        // 2. Transf√©rer TRG de l'acheteur vers le vendeur (wallet direct)
        const payment = quantity * price;
        const trgToken = new ethers.Contract(addresses.TRG, tokenABI, wallet);
        const transferPaymentTx = await trgToken.transferFrom(
            buyerAddress,
            sellerAddress,
            ethers.utils.parseUnits(payment.toString(), 18)
        );
        await transferPaymentTx.wait();
        console.log("‚úÖ Paiement transf√©r√© (wallet-to-wallet):", transferPaymentTx.hash);
        
        // 3. Mettre √† jour les ordres en base
        await new Promise((resolve, reject) => {
            db.run(
                `UPDATE orders SET status = 'filled' WHERE asset_symbol = ? AND order_type = 'sell' AND user_address = ? AND status = 'pending'`,
                [assetSymbol, sellerAddress],
                function(err) {
                    if (err) reject(err);
                    else resolve();
                }
            );
        });
        
        await new Promise((resolve, reject) => {
            db.run(
                `UPDATE orders SET status = 'filled' WHERE asset_symbol = ? AND order_type = 'buy' AND user_address = ? AND status = 'pending'`,
                [assetSymbol, buyerAddress],
                function(err) {
                    if (err) reject(err);
                    else resolve();
                }
            );
        });
        
        console.log("‚úÖ Trade ex√©cut√© avec succ√®s sur la blockchain");
        
        res.json({
            success: true,
            message: 'Trade ex√©cut√© sur la blockchain avec succ√®s',
            transactionDetails: {
                asset: `${quantity} ${assetSymbol}`,
                payment: `${payment} TRG`,
                buyer: buyerAddress,
                seller: sellerAddress,
                assetTxHash: transferAssetTx.hash,
                paymentTxHash: transferPaymentTx.hash
            }
        });
        
    } catch (error) {
        console.error('‚ùå Erreur trade blockchain:', error);
        res.status(500).json({
            success: false,
            error: error.message
        });
    }
});

// Route pour matcher automatiquement les ordres
app.post('/api/match-orders/:symbol', async (req, res) => {
    const symbol = req.params.symbol;
    
    try {
        console.log('üéØ Matching orders pour', symbol);
        
        // R√©cup√©rer les ordres pending
        const buyOrders = await new Promise((resolve, reject) => {
            db.all(
                `SELECT * FROM orders WHERE asset_symbol = ? AND order_type = 'buy' AND status = 'pending' ORDER BY price DESC`,
                [symbol],
                (err, rows) => err ? reject(err) : resolve(rows)
            );
        });
        
        const sellOrders = await new Promise((resolve, reject) => {
            db.all(
                `SELECT * FROM orders WHERE asset_symbol = ? AND order_type = 'sell' AND status = 'pending' ORDER BY price ASC`,
                [symbol],
                (err, rows) => err ? reject(err) : resolve(rows)
            );
        });
        
        const matches = [];
        
        // Algorithme de matching simple
        for (const buyOrder of buyOrders) {
            for (const sellOrder of sellOrders) {
                if (buyOrder.price >= sellOrder.price && buyOrder.quantity === sellOrder.quantity) {
                    // Match trouv√© !
                    console.log('üí• Match trouv√©!', buyOrder.id, 'vs', sellOrder.id);
                    
                    // Ex√©cuter le trade
                    const tradeResult = await fetch('http://localhost:3001/api/execute-trade', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            buyerAddress: buyOrder.user_address,
                            sellerAddress: sellOrder.user_address,
                            assetSymbol: symbol,
                            quantity: buyOrder.quantity,
                            price: sellOrder.price
                        })
                    });
                    
                    matches.push({
                        buyOrder: buyOrder.id,
                        sellOrder: sellOrder.id,
                        price: sellOrder.price,
                        quantity: buyOrder.quantity
                    });
                    
                    break; // Sortir de la boucle interne
                }
            }
        }
        
        res.json({
            success: true,
            matches: matches,
            message: `${matches.length} trades ex√©cut√©s`
        });
        
    } catch (error) {
        console.error('‚ùå Erreur matching:', error);
        res.status(500).json({
            success: false,
            error: error.message
        });
    }
});


// Route sp√©cifique pour les balances vault
app.get("/api/vault-balances/:address", async (req, res) => {
    const userAddress = req.params.address;
    
    try {
        console.log("üè¶ R√©cup√©ration balances vault pour:", userAddress);
        
        // Configuration ethers.js
        const provider = new ethers.providers.JsonRpcProvider("http://localhost:8545");
        
        // Charger les adresses des contrats
        let addresses;
        let addressesPath;
        
        const possiblePaths = [
            path.join(__dirname, "../contracts/deployed-addresses.json"),
            path.join(__dirname, "../contracts/scripts/deployed-addresses.json"),
            path.join(__dirname, "./deployed-addresses.json")
        ];
        
        for (const testPath of possiblePaths) {
            if (fs.existsSync(testPath)) {
                addressesPath = testPath;
                break;
            }
        }
        
        addresses = JSON.parse(fs.readFileSync(addressesPath, "utf8"));
        // Fallback global VAULT -> TradingVault
        if (!addresses.VAULT && addresses.VAULT) {
            addresses.VAULT = addresses.VAULT;
        }
        if (addresses.VAULT) {
            addresses.VAULT = addresses.VAULT;
        }
        
        // Charger l'ABI du vault
        const vaultABI = JSON.parse(fs.readFileSync(path.join(__dirname, "../contracts/artifacts/contracts/TradingVault.sol/TradingVault.json"), "utf8")).abi;
        const vault = new ethers.Contract(addresses.VAULT, vaultABI, provider);
        
        // R√©cup√©rer les balances vault uniquement
        const trgVaultBalance = await vault.getBalance(addresses.TRG, userAddress);
        const clvVaultBalance = await vault.getBalance(addresses.CLV, userAddress);
        const rooVaultBalance = await vault.getBalance(addresses.ROO, userAddress);
        
        const vaultBalances = {
            TRG: ethers.utils.formatUnits(trgVaultBalance, 18),
            CLV: ethers.utils.formatUnits(clvVaultBalance, 18),
            ROO: ethers.utils.formatUnits(rooVaultBalance, 18)
        };
        
        console.log("‚úÖ Balances vault r√©cup√©r√©es:", vaultBalances);
        
        res.json({
            success: true,
            balances: vaultBalances
        });
        
    } catch (error) {
        console.error("‚ùå Erreur r√©cup√©ration balances vault:", error);
        res.status(500).json({
            success: false,
            error: error.message
        });
    }
});

// Obtenir l'historique des prix
app.get('/api/price-history/:symbol', (req, res) => {
    const symbol = req.params.symbol;
    
    db.all(
        `SELECT * FROM price_history WHERE asset_symbol = ? ORDER BY timestamp ASC`,
        [symbol],
        (err, rows) => {
            if (err) {
                res.status(500).json({ success: false, error: err.message });
            } else {
                res.json({ success: true, history: rows });
            }
        }
    );
});

// D√©marrage du serveur
app.listen(PORT, () => {
    console.log(`üöÄ Serveur backend d√©marr√© sur http://localhost:${PORT}`);
    console.log(`üìã API disponible sur http://localhost:${PORT}/api/test`);
});

// Route pour obtenir les informations d'un actif
app.get('/api/assets/:symbol', (req, res) => {
    const symbol = req.params.symbol;
    
    const assetInfo = {
        TRG: { name: 'Triangle Stablecoin', type: 'stablecoin', defaultPrice: 1 },
        CLV: { name: 'Clove Company Shares', type: 'share', defaultPrice: 10 },
        ROO: { name: 'Rooibos Limited Shares', type: 'share', defaultPrice: 10 },
        GOV: { name: 'Government Bonds', type: 'bond', defaultPrice: 200 }
    };

    if (assetInfo[symbol]) {
        res.json({
            success: true,
            asset: {
                symbol: symbol,
                ...assetInfo[symbol]
            }
        });
    } else {
        res.status(404).json({
            success: false,
            error: 'Asset not found'
        });
    }
});

// Route pour obtenir le carnet d'ordres d'un actif
app.get('/api/orderbook/:symbol', (req, res) => {
    const symbol = req.params.symbol;
    
    db.all(
        `SELECT * FROM orders WHERE asset_symbol = ? AND status = 'pending' ORDER BY 
         CASE WHEN order_type = 'sell' THEN price END ASC,
         CASE WHEN order_type = 'buy' THEN price END DESC`,
        [symbol],
        (err, rows) => {
            if (err) {
                res.status(500).json({ success: false, error: err.message });
            } else {
                const buyOrders = rows.filter(order => order.order_type === 'buy');
                const sellOrders = rows.filter(order => order.order_type === 'sell');
                
                res.json({
                    success: true,
                    orderbook: {
                        buy: buyOrders,
                        sell: sellOrders
                    }
                });
            }
        }
    );
});

// Route pour obtenir l'historique des prix avec donn√©es par d√©faut
app.get('/api/price-history/:symbol', (req, res) => {
    const symbol = req.params.symbol;
    
    db.all(
        `SELECT * FROM price_history WHERE asset_symbol = ? ORDER BY timestamp ASC`,
        [symbol],
        (err, rows) => {
            if (err) {
                res.status(500).json({ success: false, error: err.message });
            } else {
                // Si pas d'historique, cr√©er des donn√©es par d√©faut
                if (rows.length === 0) {
                    const defaultPrices = {
                        TRG: 1,
                        CLV: 10,
                        ROO: 10,
                        GOV: 200
                    };
                    
                    const defaultHistory = [];
                    const now = new Date();
                    for (let i = 29; i >= 0; i--) {
                        const date = new Date(now.getTime() - i * 24 * 60 * 60 * 1000);
                        defaultHistory.push({
                            asset_symbol: symbol,
                            price: defaultPrices[symbol] || 10,
                            timestamp: date.toISOString()
                        });
                    }
                    
                    res.json({
                        success: true,
                        history: defaultHistory
                    });
                } else {
                    res.json({
                        success: true,
                        history: rows
                    });
                }
            }
        }
    );
});

// Route pour cr√©er un ordre avec d√©p√¥t au vault
app.post('/api/create-order', async (req, res) => {
    const { userAddress, assetSymbol, orderType, quantity, price } = req.body;
    
    try {
        console.log('üìù Cr√©ation ordre avec escrow:', { userAddress, assetSymbol, orderType, quantity, price });
        
        // Configuration ethers.js
        const provider = new ethers.providers.JsonRpcProvider("http://localhost:8545");
        const deployerPrivateKey = "0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80";
        const wallet = new ethers.Wallet(deployerPrivateKey, provider);
        
        // Charger les adresses
        let addresses;
        const possiblePaths = [
            path.join(__dirname, "../contracts/deployed-addresses.json"),
            path.join(__dirname, "../contracts/scripts/deployed-addresses.json")
        ];
        
        for (const testPath of possiblePaths) {
            if (fs.existsSync(testPath)) {
                addresses = JSON.parse(fs.readFileSync(testPath, 'utf8'));
        // Fallback global VAULT -> TradingVault
        if (!addresses.VAULT && addresses.VAULT) {
            addresses.VAULT = addresses.VAULT;
        }
                break;
            }
        }
        
        if (addresses.VAULT) {
            addresses.VAULT = addresses.VAULT;
        }
        
        // Charger les contrats
        const vaultABI = JSON.parse(fs.readFileSync(path.join(__dirname, '../contracts/artifacts/contracts/TradingVault.sol/TradingVault.json'), 'utf8')).abi;
        const tokenABI = JSON.parse(fs.readFileSync(path.join(__dirname, '../contracts/artifacts/contracts/StableCoin.sol/StableCoin.json'), 'utf8')).abi;
        
        const vault = new ethers.Contract(addresses.VAULT, vaultABI, wallet);
        
        // Simuler le d√©p√¥t au vault (ici on suppose que l'utilisateur a d√©j√† approuv√©)
        console.log(`üì¶ Ordre cr√©√© - Les fonds seront dans le vault lors de l'ex√©cution`);
        
        // Cr√©er l'ordre en base
        db.run(
            `INSERT INTO orders (user_address, asset_symbol, order_type, quantity, price) VALUES (?, ?, ?, ?, ?)`,
            [userAddress, assetSymbol, orderType, quantity, price],
            function(err) {
                if (err) {
                    console.error('Erreur cr√©ation ordre:', err);
                    res.status(500).json({ success: false, error: err.message });
                } else {
                    console.log('‚úÖ Ordre cr√©√© avec ID:', this.lastID);
                    
                    // D√©clencher le matching automatique
                    fetch(`http://localhost:3001/api/match-orders/${assetSymbol}`, {
                        method: 'POST'
                    }).catch(err => console.log('Matching en arri√®re-plan:', err.message));
                    
                    res.json({ 
                        success: true, 
                        orderId: this.lastID,
                        message: 'Ordre cr√©√© avec succ√®s - Matching en cours...'
                    });
                }
            }
        );
        
    } catch (error) {
        console.error('‚ùå Erreur cr√©ation ordre:', error);
        res.status(500).json({
            success: false,
            error: error.message
        });
    }
});

// Route pour cr√©er un ordre avec d√©p√¥t automatique au vault
// Route pour cr√©er un ordre simple (sans escrow)
app.post("/api/create-order-with-deposit", async (req, res) => {
    const { userAddress, assetSymbol, orderType, quantity, price } = req.body;
    
    try {
        console.log("üìù Cr√©ation ordre SIMPLE:", { userAddress, assetSymbol, orderType, quantity, price });
        
        // Cr√©er l'ordre directement en base de donn√©es
        db.run(
            `INSERT INTO orders (user_address, asset_symbol, order_type, quantity, price) VALUES (?, ?, ?, ?, ?)`,
            [userAddress, assetSymbol, orderType, quantity, price],
            function(err) {
                if (err) {
                    console.error("Erreur cr√©ation ordre:", err);
                    res.status(500).json({ success: false, error: err.message });
                } else {
                    console.log("‚úÖ Ordre cr√©√© avec ID:", this.lastID);
                    
                    // D√©clencher le matching automatique
                    setTimeout(() => {
                        fetch(`http://localhost:3001/api/match-orders/${assetSymbol}`, {
                            method: "POST"
                        }).catch(err => console.log("Matching:", err.message));
                    }, 1000);
                    
                    res.json({ 
                        success: true, 
                        orderId: this.lastID,
                        message: "Ordre cr√©√© - Matching en cours..."
                    });
                }
            }
        );
        
    } catch (error) {
        console.error("‚ùå Erreur cr√©ation ordre:", error);
        res.status(500).json({
            success: false,
            error: error.message
        });
    }
});

// Route pour v√©rifier les approbations
app.get('/api/check-allowance/:userAddress/:tokenSymbol/:amount', async (req, res) => {
    const { userAddress, tokenSymbol, amount } = req.params;
    
    try {
        const provider = new ethers.providers.JsonRpcProvider("http://localhost:8545");
        
        // Charger les adresses
        let addresses;
        const possiblePaths = [
            path.join(__dirname, "../contracts/deployed-addresses.json"),
            path.join(__dirname, "../contracts/scripts/deployed-addresses.json")
        ];
        
        for (const testPath of possiblePaths) {
            if (fs.existsSync(testPath)) {
                addresses = JSON.parse(fs.readFileSync(testPath, 'utf8'));
                break;
            }
        }
        
        if (addresses.VAULT) {
            addresses.TradingVault = addresses.VAULT;
        }
        
        const tokenABI = JSON.parse(fs.readFileSync(path.join(__dirname, '../contracts/artifacts/contracts/StableCoin.sol/StableCoin.json'), 'utf8')).abi;
        const token = new ethers.Contract(addresses[tokenSymbol], tokenABI, provider);
        
        const allowance = await token.allowance(userAddress, addresses.TradingVault);
        const requiredAmount = ethers.utils.parseUnits(amount.toString(), 18);
        
        const hasEnoughAllowance = allowance.gte(requiredAmount);
        
        res.json({
            success: true,
            hasAllowance: hasEnoughAllowance,
            currentAllowance: ethers.utils.formatUnits(allowance, 18),
            requiredAmount: amount
        });
        
    } catch (error) {
        console.error('‚ùå Erreur v√©rification allowance:', error);
        res.status(500).json({ success: false, error: error.message });
    }
});

// Route pour cr√©er un ordre avec v√©rification d'approbation
app.post('/api/create-order-with-approval', async (req, res) => {
    const { userAddress, assetSymbol, orderType, quantity, price } = req.body;
    
    try {
        console.log('üìù Cr√©ation ordre avec approbation:', { userAddress, assetSymbol, orderType, quantity, price });
        
        // D√©terminer quel token et montant sont n√©cessaires
        let tokenNeeded, amountNeeded;
        
        if (orderType === 'sell') {
            tokenNeeded = assetSymbol;
            amountNeeded = quantity;
        } else {
            tokenNeeded = 'TRG';
            amountNeeded = quantity * price;
        }
        
        // V√©rifier l'approbation
        const allowanceResponse = await fetch(`http://localhost:3001/api/check-allowance/${userAddress}/${tokenNeeded}/${amountNeeded}`);
        const allowanceData = await allowanceResponse.json();
        
        if (!allowanceData.hasAllowance) {
            return res.status(400).json({
                success: false,
                error: 'Approbation insuffisante',
                needsApproval: true,
                tokenNeeded: tokenNeeded,
                amountNeeded: amountNeeded
            });
        }
        
        // Cr√©er l'ordre si approbation OK
        db.run(
            `INSERT INTO orders (user_address, asset_symbol, order_type, quantity, price, status) VALUES (?, ?, ?, ?, ?, 'pending')`,
            [userAddress, assetSymbol, orderType, quantity, price],
            function(err) {
                if (err) {
                    console.error('Erreur cr√©ation ordre:', err);
                    res.status(500).json({ success: false, error: err.message });
                } else {
                    console.log('‚úÖ Ordre cr√©√© avec approbation - ID:', this.lastID);
                    
                    // D√©clencher le matching automatique
                    setTimeout(() => {
                        fetch(`http://localhost:3001/api/match-orders/${assetSymbol}`, {
                            method: 'POST'
                        }).catch(err => console.log('Matching:', err.message));
                    }, 1000);
                    
                    res.json({ 
                        success: true, 
                        orderId: this.lastID,
                        message: 'Ordre cr√©√© avec approbation - Matching en cours...'
                    });
                }
            }
        );
        
    } catch (error) {
        console.error('‚ùå Erreur cr√©ation ordre avec approbation:', error);
        res.status(500).json({
            success: false,
            error: error.message
        });
    }
});
// üöÄ NOUVELLE ROUTE CORRIG√âE POUR EXECUTE-TRADE

// Route pour ex√©cuter un trade r√©el sur blockchain AVEC VAULT
app.post('/api/execute-trade', async (req, res) => {
    const { buyerAddress, sellerAddress, assetSymbol, quantity, price } = req.body;
    
    try {
        console.log('üîó Ex√©cution trade blockchain R√âELLE:', { buyerAddress, sellerAddress, assetSymbol, quantity, price });
        
        // Charger adresses des contrats
        const addressesPath = path.join(__dirname, '../contracts/deployed-addresses.json');
        let addresses;
        if (fs.existsSync(addressesPath)) {
            addresses = JSON.parse(fs.readFileSync(addressesPath, 'utf8'));
        } else {
            // Fallback si fichier pas trouv√©
            addresses = {
                TRG: '0x1429859428C0aBc9C2C47C8Ee9FBaf82cFA0F20f',
                CLV: '0xB0D4afd8879eD9F52b28595d31B441D079B2Ca07',
                ROO: '0x162A433068F51e18b7d13932F27e66a3f99E6890',
                GOV: '0x922D6956C99E12DFeB3224DEA977D0939758A1Fe',
                VAULT: '0x5081a39b8A5f0E35a8D959395a630b68B74Dd30f'
            };
        }
        
        console.log('üîç DEBUG - Utilisation adresses:', addresses);
        
        // Configuration blockchain
        const provider = new ethers.providers.JsonRpcProvider('http://127.0.0.1:8545');
        const deployerPrivateKey = "0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80";
        const wallet = new ethers.Wallet(deployerPrivateKey, provider);
        
        // ABI contracts
        const erc20ABI = [
            "function transfer(address to, uint256 amount) returns (bool)",
            "function transferFrom(address from, address to, uint256 amount) returns (bool)",
            "function balanceOf(address owner) view returns (uint256)",
            "function approve(address spender, uint256 amount) returns (bool)",
            "function allowance(address owner, address spender) view returns (uint256)"
        ];
        
        const vaultABI = [
            "function getUserTokenBalance(address user, address tokenAddress) external view returns (uint256)",
            "function operateWithdrawal(address user, address tokenAddress, uint256 amount) external"
        ];
        
        // Cr√©er contrats
        const assetContract = new ethers.Contract(addresses[assetSymbol], erc20ABI, provider);
        const trgContract = new ethers.Contract(addresses.TRG, erc20ABI, provider);
        const vaultContract = new ethers.Contract(addresses.VAULT, vaultABI, wallet);
        
        const quantityWei = ethers.utils.parseEther(quantity.toString());
        const totalPriceWei = ethers.utils.parseEther((quantity * price).toString());
        
        console.log('üìã Ex√©cution du trade sur la blockchain...');
        
        // √âTAPE 1: V√©rifier les balances vault
        const sellerAssetBalance = await vaultContract.getUserTokenBalance(sellerAddress, addresses[assetSymbol]);
        const buyerTrgBalance = await vaultContract.getUserTokenBalance(buyerAddress, addresses.TRG);
        
        console.log('üí∞ Balances vault:');
        console.log(`- Vendeur ${assetSymbol}:`, ethers.utils.formatEther(sellerAssetBalance));
        console.log(`- Acheteur TRG:`, ethers.utils.formatEther(buyerTrgBalance));
        
        // V√©rifier que les fonds sont suffisants
        if (sellerAssetBalance.lt(quantityWei)) {
            throw new Error(`Vendeur n'a pas assez de ${assetSymbol} dans le vault`);
        }
        
        if (buyerTrgBalance.lt(totalPriceWei)) {
            throw new Error(`Acheteur n'a pas assez de TRG dans le vault`);
        }
        
        // √âTAPE 2: Ex√©cuter le swap depuis le vault
        console.log('üîÑ Transfert asset du vault...');
        const assetTx = await vaultContract.operateWithdrawal(
            sellerAddress,
            addresses[assetSymbol],
            quantityWei
        );
        await assetTx.wait();
        console.log('‚úÖ Asset retir√© du vault vendeur');
        
        console.log('üîÑ Transfert TRG du vault...');
        const trgTx = await vaultContract.operateWithdrawal(
            buyerAddress,
            addresses.TRG,
            totalPriceWei
        );
        await trgTx.wait();
        console.log('‚úÖ TRG retir√© du vault acheteur');
        
        // √âTAPE 3: Transf√©rer directement aux utilisateurs
        console.log('üîÑ Envoi asset √† l\'acheteur...');
        const transferAssetTx = await assetContract.connect(wallet).transfer(buyerAddress, quantityWei);
        await transferAssetTx.wait();
        console.log('‚úÖ Asset envoy√© √† l\'acheteur');
        
        console.log('üîÑ Envoi TRG au vendeur...');
        const transferTrgTx = await trgContract.connect(wallet).transfer(sellerAddress, totalPriceWei);
        await transferTrgTx.wait();
        console.log('‚úÖ TRG envoy√© au vendeur');
        
        // √âTAPE 4: Mettre √† jour les ordres en base
        await new Promise((resolve, reject) => {
            db.run(
                `UPDATE orders SET status = 'filled' WHERE asset_symbol = ? AND order_type = 'sell' AND user_address = ? AND status = 'pending'`,
                [assetSymbol, sellerAddress],
                function(err) {
                    if (err) reject(err);
                    else resolve();
                }
            );
        });
        
        await new Promise((resolve, reject) => {
            db.run(
                `UPDATE orders SET status = 'filled' WHERE asset_symbol = ? AND order_type = 'buy' AND user_address = ? AND status = 'pending'`,
                [assetSymbol, buyerAddress],
                function(err) {
                    if (err) reject(err);
                    else resolve();
                }
            );
        });
        
        console.log('‚úÖ Trade ex√©cut√© avec succ√®s sur la blockchain!');
        
        res.json({
            success: true,
            message: 'Trade ex√©cut√© sur la blockchain avec succ√®s',
            transactionDetails: {
                asset: `${quantity} ${assetSymbol}`,
                payment: `${quantity * price} TRG`,
                buyer: buyerAddress,
                seller: sellerAddress,
                assetTxHash: transferAssetTx.hash,
                paymentTxHash: transferTrgTx.hash
            }
        });
        
    } catch (error) {
        console.error('‚ùå Erreur trade blockchain:', error);
        res.status(500).json({
            success: false,
            error: error.message
        });
    }
});

