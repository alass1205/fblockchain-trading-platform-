const express = require('express');
const cors = require('cors');
const sqlite3 = require('sqlite3').verbose();
const multer = require('multer');
const path = require('path');
const fs = require('fs');
const { ethers } = require('ethers');

const app = express();
const PORT = 3001;

// Middleware
app.use(cors());
app.use(express.json());
app.use('/uploads', express.static('uploads'));

// Cr√©er le dossier uploads s'il n'existe pas
if (!fs.existsSync('uploads')) {
    fs.mkdirSync('uploads');
}

// Configuration multer pour upload fichiers
const storage = multer.diskStorage({
    destination: (req, file, cb) => {
        cb(null, 'uploads/');
    },
    filename: (req, file, cb) => {
        cb(null, Date.now() + '-' + file.originalname);
    }
});
const upload = multer({ storage: storage });

// Base de donn√©es SQLite
const db = new sqlite3.Database('./trading.db');

// Initialisation de la base de donn√©es
db.serialize(() => {
    db.run(`CREATE TABLE IF NOT EXISTS users (
        wallet_address TEXT PRIMARY KEY,
        legal_name TEXT NOT NULL,
        passport_picture TEXT,
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP
    )`);

    db.run(`CREATE TABLE IF NOT EXISTS orders (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        user_address TEXT NOT NULL,
        asset_symbol TEXT NOT NULL,
        order_type TEXT NOT NULL,
        quantity REAL NOT NULL,
        price REAL NOT NULL,
        status TEXT DEFAULT 'pending',
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        mode TEXT DEFAULT 'vault'
    )`);

    db.run(`CREATE TABLE IF NOT EXISTS assets (
        symbol TEXT PRIMARY KEY,
        name TEXT NOT NULL,
        type TEXT NOT NULL,
        contract_address TEXT,
        current_price REAL DEFAULT 10.0
    )`);

    db.run(`CREATE TABLE IF NOT EXISTS price_history (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        asset_symbol TEXT NOT NULL,
        price REAL NOT NULL,
        timestamp DATETIME DEFAULT CURRENT_TIMESTAMP
    )`);

    // Table pour l'historique des trades
    db.run(`CREATE TABLE IF NOT EXISTS trades (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        asset_symbol TEXT NOT NULL,
        buyer_address TEXT NOT NULL,
        seller_address TEXT NOT NULL,
        quantity REAL NOT NULL,
        price REAL NOT NULL,
        total_amount REAL NOT NULL,
        tx_hash TEXT,
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP
    )`);

    console.log('‚úÖ Base de donn√©es initialis√©e');
});

// Routes API

// Test de l'API
app.get('/api/test', (req, res) => {
    res.json({ success: true, message: 'API backend fonctionne!' });
});

// Inscription utilisateur (CORRIG√âE)
app.post('/api/register', upload.single('passport'), (req, res) => {
    const { walletAddress, legalName } = req.body;
    const passportPicture = req.file ? req.file.filename : null;

    console.log('üìù Inscription utilisateur:', { walletAddress, legalName, passportPicture });

    db.run(
        'INSERT OR REPLACE INTO users (wallet_address, legal_name, passport_picture) VALUES (?, ?, ?)',
        [walletAddress, legalName, passportPicture],
        function(err) {
            if (err) {
                console.error('‚ùå Erreur inscription:', err);
                res.status(500).json({ success: false, error: err.message });
            } else {
                console.log('‚úÖ Utilisateur inscrit:', walletAddress);
                res.json({ success: true, message: 'Utilisateur enregistr√© avec succ√®s' });
            }
        }
    );
});

// V√©rifier si un utilisateur est inscrit
app.get('/api/user/:address', (req, res) => {
    const { address } = req.params;
    
    db.get(
        'SELECT * FROM users WHERE wallet_address = ?',
        [address],
        (err, row) => {
            if (err) {
                res.status(500).json({ success: false, error: err.message });
            } else if (row) {
                res.json({ success: true, registered: true, user: row });
            } else {
                res.json({ success: true, registered: false });
            }
        }
    );
});

// R√©cup√©ration des balances blockchain
app.get('/api/balances/:address', async (req, res) => {
    const { address } = req.params;
    
    try {
        console.log('üìä R√©cup√©ration balances pour:', address);
        
        const provider = new ethers.providers.JsonRpcProvider('http://127.0.0.1:8545');
        const addressesPath = path.join(__dirname, 'deployed-addresses.json');
        const addresses = JSON.parse(fs.readFileSync(addressesPath, 'utf8'));
        
        console.log('üìã DEBUG - Adresses charg√©es:', addresses);
        
        const erc20ABI = [
            "function balanceOf(address owner) view returns (uint256)"
        ];
        
        const bondABI = [
            "function getBondsByOwner(address owner) view returns (uint256[])"
        ];
        
        const balances = {};
        
        // TRG Balance
        const trgContract = new ethers.Contract(addresses.TRG, erc20ABI, provider);
        const trgBalance = await trgContract.balanceOf(address);
        balances.TRG = ethers.utils.formatEther(trgBalance);
        
        // CLV Balance
        const clvContract = new ethers.Contract(addresses.CLV, erc20ABI, provider);
        const clvBalance = await clvContract.balanceOf(address);
        balances.CLV = ethers.utils.formatEther(clvBalance);
        
        // ROO Balance
        const rooContract = new ethers.Contract(addresses.ROO, erc20ABI, provider);
        const rooBalance = await rooContract.balanceOf(address);
        balances.ROO = ethers.utils.formatEther(rooBalance);
        
        // GOV Bonds
        try {
            const govContract = new ethers.Contract(addresses.GOV, bondABI, provider);
            const bonds = await govContract.getBondsByOwner(address);
            balances.GOV = bonds.length.toString();
        } catch (error) {
            console.log('‚ö†Ô∏è Erreur GOV bonds:', error.message);
            balances.GOV = '0';
        }

        console.log('‚úÖ Balances r√©cup√©r√©es:', balances);
        
        res.json({
            success: true,
            address: address,
            balances: balances
        });

    } catch (error) {
        console.error('‚ùå Erreur balances:', error);
        res.status(500).json({
            success: false,
            error: error.message
        });
    }
});

// Route pour r√©cup√©rer les balances vault
app.get('/api/vault-balances/:address', async (req, res) => {
    const { address } = req.params;
    
    try {
        console.log('üè¶ R√©cup√©ration balances vault pour:', address);
        
        const provider = new ethers.providers.JsonRpcProvider('http://127.0.0.1:8545');
        const addressesPath = path.join(__dirname, 'deployed-addresses.json');
        const addresses = JSON.parse(fs.readFileSync(addressesPath, 'utf8'));
        
        const vaultABI = [
            "function getBalance(address token, address user) external view returns (uint256)"
        ];
        
        const vaultContract = new ethers.Contract(addresses.TradingVault, vaultABI, provider);
        const vaultBalances = {};
        
        // TRG dans vault
        const trgVault = await vaultContract.getBalance(addresses.TRG, address);
        vaultBalances.TRG = ethers.utils.formatEther(trgVault);
        
        // CLV dans vault
        const clvVault = await vaultContract.getBalance(addresses.CLV, address);
        vaultBalances.CLV = ethers.utils.formatEther(clvVault);
        
        // ROO dans vault
        const rooVault = await vaultContract.getBalance(addresses.ROO, address);
        vaultBalances.ROO = ethers.utils.formatEther(rooVault);
        
        // GOV pas dans vault (bonds)
        vaultBalances.GOV = '0';
        
        console.log('‚úÖ Balances vault r√©cup√©r√©es:', vaultBalances);
        
        res.json({
            success: true,
            address: address,
            balances: vaultBalances
        });
        
    } catch (error) {
        console.error('‚ùå Erreur vault balances:', error);
        res.status(500).json({
            success: false,
            error: error.message
        });
    }
});

// Route pour v√©rifier les approbations
app.get('/api/check-allowance/:userAddress/:tokenSymbol/:amount', async (req, res) => {
    const { userAddress, tokenSymbol, amount } = req.params;
    
    try {
        console.log('üîç V√©rification allowance:', { userAddress, tokenSymbol, amount });
        
        const provider = new ethers.providers.JsonRpcProvider('http://127.0.0.1:8545');
        const addressesPath = path.join(__dirname, 'deployed-addresses.json');
        const addresses = JSON.parse(fs.readFileSync(addressesPath, 'utf8'));
        
        const tokenABI = [
            "function allowance(address owner, address spender) view returns (uint256)"
        ];
        
        const tokenContract = new ethers.Contract(addresses[tokenSymbol], tokenABI, provider);
        const allowance = await tokenContract.allowance(userAddress, addresses.TradingVault);
        const requiredAmount = ethers.utils.parseUnits(amount.toString(), 18);
        
        const hasEnoughAllowance = allowance.gte(requiredAmount);
        
        res.json({
            success: true,
            hasAllowance: hasEnoughAllowance,
            currentAllowance: ethers.utils.formatUnits(allowance, 18),
            requiredAmount: amount
        });
        
    } catch (error) {
        console.error('‚ùå Erreur v√©rification allowance:', error);
        res.status(500).json({ success: false, error: error.message });
    }
});

// üîí MODE APPROBATION - Cr√©ation d'ordres avec approbation (recommand√©)
app.post('/api/create-order-with-approval', (req, res) => {
    const { userAddress, assetSymbol, orderType, quantity, price } = req.body;
    
    try {
        console.log('üìù Cr√©ation ordre avec approbation (mode s√©curis√©):', { userAddress, assetSymbol, orderType, quantity, price });
        
        db.run(
            'INSERT INTO orders (user_address, asset_symbol, order_type, quantity, price, mode) VALUES (?, ?, ?, ?, ?, ?)',
            [userAddress, assetSymbol, orderType, quantity, price, 'approval'],
            function(err) {
                if (err) {
                    res.status(500).json({ success: false, error: err.message });
                } else {
                    console.log('‚úÖ Ordre cr√©√© avec approbation - ID:', this.lastID);
                    
                    setTimeout(() => {
                        matchOrders(assetSymbol);
                    }, 1000);
                    
                    res.json({ 
                        success: true, 
                        orderId: this.lastID,
                        message: 'Ordre cr√©√© avec succ√®s (mode approbation)',
                        mode: 'approval'
                    });
                }
            }
        );
        
    } catch (error) {
        console.error('‚ùå Erreur cr√©ation ordre:', error);
        res.status(500).json({ success: false, error: error.message });
    }
});

// üè¶ MODE VAULT - Cr√©ation d'ordres standard (pour audit/d√©mo)
app.post('/api/orders', (req, res) => {
    const { userAddress, assetSymbol, orderType, quantity, price } = req.body;
    
    console.log('üìù Cr√©ation ordre mode vault (d√©mo):', { userAddress, assetSymbol, orderType, quantity, price });
    
    db.run(
        'INSERT INTO orders (user_address, asset_symbol, order_type, quantity, price, mode) VALUES (?, ?, ?, ?, ?, ?)',
        [userAddress, assetSymbol, orderType, quantity, price, 'vault'],
        function(err) {
            if (err) {
                console.error('‚ùå Erreur cr√©ation ordre vault:', err);
                res.status(500).json({ success: false, error: err.message });
            } else {
                console.log('‚úÖ Ordre cr√©√© mode vault - ID:', this.lastID);
                
                setTimeout(() => {
                    matchOrders(assetSymbol);
                }, 1000);
                
                res.json({ 
                    success: true, 
                    orderId: this.lastID,
                    message: 'Ordre cr√©√© avec succ√®s (mode vault)',
                    mode: 'vault'
                });
            }
        }
    );
});

// R√©cup√©ration des ordres par asset
app.get('/api/orders/:symbol', (req, res) => {
    const { symbol } = req.params;
    
    db.all(
        'SELECT * FROM orders WHERE asset_symbol = ? AND status = ? ORDER BY created_at DESC',
        [symbol, 'pending'],
        (err, rows) => {
            if (err) {
                res.status(500).json({ success: false, error: err.message });
            } else {
                res.json({ success: true, orders: rows });
            }
        }
    );
});

// Route pour r√©cup√©rer les ordres d'un utilisateur
app.get('/api/user-orders/:address', (req, res) => {
    const { address } = req.params;
    
    db.all(
        'SELECT * FROM orders WHERE user_address = ? ORDER BY created_at DESC',
        [address],
        (err, rows) => {
            if (err) {
                res.status(500).json({ success: false, error: err.message });
            } else {
                res.json({ 
                    success: true, 
                    orders: rows || []
                });
            }
        }
    );
});

// Fonction de matching avanc√©e avec trades partiels
async function matchOrders(assetSymbol) {
    console.log('üéØ Matching orders pour', assetSymbol);
    
    return new Promise((resolve) => {
        db.all(
            'SELECT * FROM orders WHERE asset_symbol = ? AND status = ? ORDER BY created_at ASC',
            [assetSymbol, 'pending'],
            async (err, orders) => {
                if (err) {
                    console.error('‚ùå Erreur matching:', err);
                    resolve();
                    return;
                }
                
                const buyOrders = orders.filter(o => o.order_type === 'buy').sort((a, b) => b.price - a.price);
                const sellOrders = orders.filter(o => o.order_type === 'sell').sort((a, b) => a.price - b.price);
                
                console.log('üìä Ordres √† matcher:', { 
                    buy: buyOrders.length, 
                    sell: sellOrders.length 
                });
                
                // Afficher les ordres pour debugging
                console.log('üîµ Ordres d\'achat:', buyOrders.map(o => `${o.quantity}@${o.price} (${o.user_address.slice(0,8)})`));
                console.log('üî¥ Ordres de vente:', sellOrders.map(o => `${o.quantity}@${o.price} (${o.user_address.slice(0,8)})`));
                
                for (const sellOrder of sellOrders) {
                    for (const buyOrder of buyOrders) {
                        // Condition de matching : prix compatible et utilisateurs diff√©rents
                        if (buyOrder.price >= sellOrder.price && 
                            buyOrder.user_address !== sellOrder.user_address &&
                            buyOrder.quantity > 0 && sellOrder.quantity > 0) {
                            
                            // D√©terminer la quantit√© √† √©changer (minimum des deux)
                            const tradeQuantity = Math.min(buyOrder.quantity, sellOrder.quantity);
                            
                            // NOUVEAU: D√©terminer le mode de trade (priorit√© au mode vault pour compatibilit√©)
                            const tradeMode = (buyOrder.mode === 'vault' || sellOrder.mode === 'vault') ? 'vault' : 'approval';
                            
                            console.log('üí• Match trouv√©!', {
                                buy: `${buyOrder.quantity} @ ${buyOrder.price} TRG [${buyOrder.mode}]`,
                                sell: `${sellOrder.quantity} @ ${sellOrder.price} TRG [${sellOrder.mode}]`,
                                tradeQuantity: tradeQuantity,
                                tradeMode: tradeMode,
                                type: tradeQuantity === buyOrder.quantity && tradeQuantity === sellOrder.quantity ? 'FULL' :
                                      tradeQuantity === buyOrder.quantity ? 'BUY_FILLED' :
                                      tradeQuantity === sellOrder.quantity ? 'SELL_FILLED' : 'PARTIAL'
                            });
                            
                            try {
                                // NOUVEAU: Choisir le bon endpoint selon le mode
                                const endpoint = tradeMode === 'vault' ? '/api/execute-trade' : '/api/execute-trade-approval';
                                
                                console.log(`üéØ Utilisation endpoint: ${endpoint} (mode: ${tradeMode})`);
                                
                                // Ex√©cuter le trade sur la blockchain
                                const response = await fetch(`http://localhost:3001${endpoint}`, {
                                    method: 'POST',
                                    headers: { 'Content-Type': 'application/json' },
                                    body: JSON.stringify({
                                        buyerAddress: buyOrder.user_address,
                                        sellerAddress: sellOrder.user_address,
                                        assetSymbol: assetSymbol,
                                        quantity: tradeQuantity,
                                        price: sellOrder.price
                                    })
                                });
                                
                                const result = await response.json();
                                
                                if (result.success) {
                                    console.log('‚úÖ Trade ex√©cut√© avec succ√®s!');
                                    
                                    // Mettre √† jour les quantit√©s des ordres
                                    const newBuyQuantity = buyOrder.quantity - tradeQuantity;
                                    const newSellQuantity = sellOrder.quantity - tradeQuantity;
                                    
                                    // Mettre √† jour l'ordre d'achat
                                    if (newBuyQuantity <= 0) {
                                        await new Promise((resolve, reject) => {
                                            db.run(
                                                'UPDATE orders SET status = ?, quantity = 0 WHERE id = ?',
                                                ['filled', buyOrder.id],
                                                (err) => err ? reject(err) : resolve()
                                            );
                                        });
                                        console.log('üîµ Ordre d\'achat compl√®tement rempli');
                                    } else {
                                        await new Promise((resolve, reject) => {
                                            db.run(
                                                'UPDATE orders SET quantity = ?, status = ? WHERE id = ?',
                                                [newBuyQuantity, 'partial', buyOrder.id],
                                                (err) => err ? reject(err) : resolve()
                                            );
                                        });
                                        console.log('üîµ Ordre d\'achat partiellement rempli:', newBuyQuantity, 'restant');
                                    }
                                    
                                    // Mettre √† jour l'ordre de vente
                                    if (newSellQuantity <= 0) {
                                        await new Promise((resolve, reject) => {
                                            db.run(
                                                'UPDATE orders SET status = ?, quantity = 0 WHERE id = ?',
                                                ['filled', sellOrder.id],
                                                (err) => err ? reject(err) : resolve()
                                            );
                                        });
                                        console.log('üî¥ Ordre de vente compl√®tement rempli');
                                    } else {
                                        await new Promise((resolve, reject) => {
                                            db.run(
                                                'UPDATE orders SET quantity = ?, status = ? WHERE id = ?',
                                                [newSellQuantity, 'partial', sellOrder.id],
                                                (err) => err ? reject(err) : resolve()
                                            );
                                        });
                                        console.log('üî¥ Ordre de vente partiellement rempli:', newSellQuantity, 'restant');
                                    }
                                    
                                } else {
                                    console.log('‚ùå Erreur lors du trade:', result.error);
                                }
                                
                            } catch (error) {
                                console.error('‚ùå Erreur ex√©cution trade:', error.message);
                            }
                            
                            // Continuer √† chercher d'autres matches possibles
                            resolve();
                            return;
                        }
                    }
                }
                
                console.log('‚è∏Ô∏è Aucun match trouv√© pour', assetSymbol);
                resolve();
            }
        );
    });
}

// Route pour ex√©cuter un trade r√©el sur blockchain (MODE VAULT)
app.post("/api/execute-trade", async (req, res) => {
    const { buyerAddress, sellerAddress, assetSymbol, quantity, price } = req.body;
    
    try {
        console.log("üîó Ex√©cution trade (mode vault):", { buyerAddress, sellerAddress, assetSymbol, quantity, price });
        
        const provider = new ethers.providers.JsonRpcProvider("http://127.0.0.1:8545");
        const deployerPrivateKey = "0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80";
        const wallet = new ethers.Wallet(deployerPrivateKey, provider);
        
        const addressesPath = path.join(__dirname, "deployed-addresses.json");
        const addresses = JSON.parse(fs.readFileSync(addressesPath, "utf8"));
        
        const vaultABI = JSON.parse(fs.readFileSync(path.join(__dirname, "../contracts/artifacts/contracts/TradingVault.sol/TradingVault.json"), "utf8")).abi;
        const vaultContract = new ethers.Contract(addresses.TradingVault, vaultABI, wallet);
        
        const quantityWei = ethers.utils.parseEther(quantity.toString());
        const totalPriceWei = ethers.utils.parseEther((quantity * price).toString());
        
        console.log("üìã Appel vault.transferFromVault() [MODE VAULT]...");
        
        // Transf√©rer asset du vendeur vers acheteur
        await vaultContract.transferFromVault(
            addresses[assetSymbol],
            sellerAddress,
            buyerAddress,
            quantityWei
        );
        
        // Transf√©rer payment de acheteur vers vendeur
        await vaultContract.transferFromVault(
            addresses.TRG,
            buyerAddress,
            sellerAddress,
            totalPriceWei
        );
        
        console.log("‚úÖ Trade vault ex√©cut√©!");
        
        // Mettre √† jour les ordres
        await new Promise((resolve, reject) => {
            db.run("UPDATE orders SET status = ? WHERE asset_symbol = ? AND order_type = ? AND user_address = ? AND status = ?",
                ["filled", assetSymbol, "sell", sellerAddress, "pending"],
                function(err) { if (err) reject(err); else resolve(); }
            );
        });
        
        await new Promise((resolve, reject) => {
            db.run("UPDATE orders SET status = ? WHERE asset_symbol = ? AND order_type = ? AND user_address = ? AND status = ?",
                ["filled", assetSymbol, "buy", buyerAddress, "pending"],
                function(err) { if (err) reject(err); else resolve(); }
            );
        });
        
        res.json({
            success: true,
            message: "Trade ex√©cut√© en mode vault",
            transactionDetails: {
                asset: `${quantity} ${assetSymbol}`,
                payment: `${quantity * price} TRG`,
                buyer: buyerAddress,
                seller: sellerAddress
            }
        });
        
    } catch (error) {
        console.error("‚ùå Erreur execution trade:", error);
        res.status(500).json({
            success: false,
            error: error.message
        });
    }
});


// üîí NOUVELLE FONCTION POUR MODE APPROBATION
app.post("/api/execute-trade-approval", async (req, res) => {
    const { buyerAddress, sellerAddress, assetSymbol, quantity, price } = req.body;
    
    try {
        console.log("üîó Ex√©cution trade (mode approbation - transfert direct):", { buyerAddress, sellerAddress, assetSymbol, quantity, price });
        
        const provider = new ethers.providers.JsonRpcProvider("http://127.0.0.1:8545");
        const deployerPrivateKey = "0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80";
        const wallet = new ethers.Wallet(deployerPrivateKey, provider);
        
        const addressesPath = path.join(__dirname, "deployed-addresses.json");
        const addresses = JSON.parse(fs.readFileSync(addressesPath, "utf8"));
        
        const tokenABI = JSON.parse(fs.readFileSync(path.join(__dirname, "../contracts/artifacts/contracts/TRGToken.sol/TRGToken.json"), "utf8")).abi;
        
        const quantityWei = ethers.utils.parseEther(quantity.toString());
        const totalPriceWei = ethers.utils.parseEther((quantity * price).toString());
        
        console.log("üìã Transferts ERC20 directs [MODE APPROBATION]...");
        
        // 1. Transf√©rer l'asset du vendeur vers l'acheteur
        const assetContract = new ethers.Contract(addresses[assetSymbol], tokenABI, wallet);
        const transferAssetTx = await assetContract.transferFrom(
            sellerAddress,
            buyerAddress,
            quantityWei
        );
        await transferAssetTx.wait();
        console.log("‚úÖ Asset transf√©r√©:", transferAssetTx.hash);
        
        // 2. Transf√©rer TRG de l'acheteur vers le vendeur
        const trgContract = new ethers.Contract(addresses.TRG, tokenABI, wallet);
        const transferPaymentTx = await trgContract.transferFrom(
            buyerAddress,
            sellerAddress,
            totalPriceWei
        );
        await transferPaymentTx.wait();
        console.log("‚úÖ Paiement transf√©r√©:", transferPaymentTx.hash);
        
        console.log("‚úÖ Trade approbation ex√©cut√©!");
        
        res.json({
            success: true,
            message: "Trade ex√©cut√© en mode approbation (transfert direct)",
            transactionDetails: {
                asset: `${quantity} ${assetSymbol}`,
                payment: `${quantity * price} TRG`,
                buyer: buyerAddress,
                seller: sellerAddress,
                assetTxHash: transferAssetTx.hash,
                paymentTxHash: transferPaymentTx.hash
            }
        });
        
    } catch (error) {
        console.error("‚ùå Erreur execution trade approbation:", error);
        res.status(500).json({
            success: false,
            error: error.message
        });
    }
});

// Route pour retirer des tokens du vault vers le wallet
app.post('/api/withdraw', async (req, res) => {
    const { userAddress, tokenSymbol, amount } = req.body;
    
    try {
        console.log('üí∞ Demande de retrait:', { userAddress, tokenSymbol, amount });
        
        const provider = new ethers.providers.JsonRpcProvider('http://127.0.0.1:8545');
        const deployerPrivateKey = "0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80";
        const wallet = new ethers.Wallet(deployerPrivateKey, provider);
        
        const addressesPath = path.join(__dirname, 'deployed-addresses.json');
        const addresses = JSON.parse(fs.readFileSync(addressesPath, 'utf8'));
        
        const vaultABI = JSON.parse(fs.readFileSync(path.join(__dirname, '../contracts/artifacts/contracts/TradingVault.sol/TradingVault.json'), 'utf8')).abi;
        const vault = new ethers.Contract(addresses.TradingVault, vaultABI, wallet);
        
        const amountWei = ethers.utils.parseUnits(amount.toString(), 18);
        
        // Appeler operateWithdrawal du vault
        const tx = await vault.operateWithdrawal(userAddress, addresses[tokenSymbol], amountWei);
        await tx.wait();
        
        console.log('‚úÖ Retrait ex√©cut√©:', tx.hash);
        
        res.json({
            success: true,
            message: 'Retrait ex√©cut√© avec succ√®s',
            txHash: tx.hash
        });
        
    } catch (error) {
        console.error('‚ùå Erreur retrait:', error);
        res.status(500).json({ success: false, error: error.message });
    }
});

// Route pour r√©cup√©rer les donn√©es d'un asset
app.get('/api/assets/:symbol', (req, res) => {
    const { symbol } = req.params;
    
    const assetData = {
        CLV: {
            symbol: 'CLV',
            name: 'Clove Company',
            type: 'share',
            currentPrice: 10,
            description: 'Actions de Clove Company',
            totalSupply: 100
        },
        ROO: {
            symbol: 'ROO', 
            name: 'Rooibos Limited',
            type: 'share',
            currentPrice: 10,
            description: 'Actions de Rooibos Limited',
            totalSupply: 100
        },
        GOV: {
            symbol: 'GOV',
            name: 'Government Bonds',
            type: 'bond',
            currentPrice: 200,
            description: 'Obligations gouvernementales (10% int√©r√™t, 1 an)',
            totalSupply: 20
        }
    };
    
    const asset = assetData[symbol];
    
    if (asset) {
        res.json({ success: true, asset: asset });
    } else {
        res.status(404).json({ success: false, error: `Asset ${symbol} non trouv√©` });
    }
});

// Route pour r√©cup√©rer le carnet d'ordres (orderbook)
app.get('/api/orderbook/:symbol', (req, res) => {
    const { symbol } = req.params;
    
    console.log('üìä R√©cup√©ration orderbook pour:', symbol);
    
    db.all(
        'SELECT * FROM orders WHERE asset_symbol = ? AND status = ? ORDER BY price DESC, created_at ASC',
        [symbol, 'pending'],
        (err, orders) => {
            if (err) {
                console.error('‚ùå Erreur orderbook:', err);
                res.status(500).json({ success: false, error: err.message });
            } else {
                const buyOrders = orders.filter(o => o.order_type === 'buy');
                const sellOrders = orders.filter(o => o.order_type === 'sell');
                
                console.log('üìà Orderbook', symbol, '- Buy:', buyOrders.length, 'Sell:', sellOrders.length);
                
                res.json({
                    success: true,
                    orderbook: {
                        symbol: symbol,
                        buyOrders: buyOrders,
                        sellOrders: sellOrders,
                        totalOrders: orders.length
                    }
                });
            }
        }
    );
});

// Route pour r√©cup√©rer l'historique des trades d'un utilisateur
app.get('/api/trades/:userAddress', (req, res) => {
    const { userAddress } = req.params;
    
    db.all(
        `SELECT * FROM trades 
         WHERE buyer_address = ? OR seller_address = ? 
         ORDER BY created_at DESC 
         LIMIT 50`,
        [userAddress, userAddress],
        (err, rows) => {
            if (err) {
                res.status(500).json({ success: false, error: err.message });
            } else {
                const trades = rows.map(trade => ({
                    ...trade,
                    side: trade.buyer_address.toLowerCase() === userAddress.toLowerCase() ? 'buy' : 'sell',
                    counterparty: trade.buyer_address.toLowerCase() === userAddress.toLowerCase() 
                        ? trade.seller_address 
                        : trade.buyer_address
                }));
                
                res.json({ 
                    success: true, 
                    trades: trades,
                    total: rows.length 
                });
            }
        }
    );
});

// Route pour l'historique global des trades par asset
app.get('/api/trades/asset/:symbol', (req, res) => {
    const { symbol } = req.params;
    
    db.all(
        'SELECT * FROM trades WHERE asset_symbol = ? ORDER BY created_at DESC LIMIT 20',
        [symbol],
        (err, rows) => {
            if (err) {
                res.status(500).json({ success: false, error: err.message });
            } else {
                res.json({ success: true, trades: rows });
            }
        }
    );
});

// Route pour v√©rifier si un utilisateur est inscrit
app.get('/api/check-registration/:address', (req, res) => {
    const { address } = req.params;
    
    db.get(
        'SELECT * FROM users WHERE wallet_address = ?',
        [address],
        (err, row) => {
            if (err) {
                res.status(500).json({ success: false, error: err.message });
            } else if (row) {
                res.json({ 
                    success: true, 
                    registered: true, 
                    user: { 
                        wallet_address: row.wallet_address,
                        legal_name: row.legal_name,
                        created_at: row.created_at
                    }
                });
            } else {
                res.json({ success: true, registered: false });
            }
        }
    );
});

// Route pour annuler un ordre
app.post('/api/cancel-order/:orderId', (req, res) => {
    const { orderId } = req.params;
    const { userAddress } = req.body;
    
    console.log('‚ùå Demande annulation ordre:', orderId, 'par', userAddress);
    
    db.get(
        'SELECT * FROM orders WHERE id = ? AND user_address = ? AND status = ?',
        [orderId, userAddress, 'pending'],
        (err, order) => {
            if (err) {
                res.status(500).json({ success: false, error: err.message });
            } else if (!order) {
                res.status(404).json({ success: false, error: 'Ordre non trouv√© ou non annulable' });
            } else {
                db.run(
                    'UPDATE orders SET status = ? WHERE id = ?',
                    ['cancelled', orderId],
                    function(err) {
                        if (err) {
                            res.status(500).json({ success: false, error: err.message });
                        } else {
                            console.log('‚úÖ Ordre annul√©:', orderId);
                            res.json({ 
                                success: true, 
                                message: 'Ordre annul√© avec succ√®s',
                                orderId: orderId
                            });
                        }
                    }
                );
            }
        }
    );
});

// Route pour obtenir les statistiques de trading
app.get('/api/stats/:symbol', (req, res) => {
    const { symbol } = req.params;
    
    Promise.all([
        // Volume des derni√®res 24h
        new Promise((resolve, reject) => {
            db.get(
                `SELECT SUM(total_amount) as volume24h, COUNT(*) as trades24h 
                 FROM trades 
                 WHERE asset_symbol = ? AND created_at > datetime('now', '-1 day')`,
                [symbol],
                (err, row) => err ? reject(err) : resolve(row)
            );
        }),
        // Prix du dernier trade
        new Promise((resolve, reject) => {
            db.get(
                'SELECT price FROM trades WHERE asset_symbol = ? ORDER BY created_at DESC LIMIT 1',
                [symbol],
                (err, row) => err ? reject(err) : resolve(row)
            );
        }),
        // Ordres en cours
        new Promise((resolve, reject) => {
            db.all(
                'SELECT order_type, COUNT(*) as count, SUM(quantity) as total_quantity FROM orders WHERE asset_symbol = ? AND status = ? GROUP BY order_type',
                [symbol, 'pending'],
                (err, rows) => err ? reject(err) : resolve(rows)
            );
        })
    ]).then(([volume24h, lastPrice, pendingOrders]) => {
        const stats = {
            symbol: symbol,
            volume24h: volume24h.volume24h || 0,
            trades24h: volume24h.trades24h || 0,
            lastPrice: lastPrice ? lastPrice.price : null,
            pendingOrders: pendingOrders.reduce((acc, order) => {
                acc[order.order_type] = {
                    count: order.count,
                    totalQuantity: order.total_quantity
                };
                return acc;
            }, {})
        };
        
        res.json({ success: true, stats: stats });
    }).catch(error => {
        console.error('‚ùå Erreur stats:', error);
        res.status(500).json({ success: false, error: error.message });
    });
});

// ======== FONCTIONS UTILITAIRES ========

// Fonction pour nettoyer les ordres expir√©s
function cleanupExpiredOrders() {
    const expiredTime = new Date(Date.now() - 24 * 60 * 60 * 1000); // 24 heures
    
    db.run(
        'UPDATE orders SET status = ? WHERE created_at < ? AND status = ?',
        ['expired', expiredTime.toISOString(), 'pending'],
        function(err) {
            if (err) {
                console.error('‚ùå Erreur nettoyage ordres expir√©s:', err);
            } else if (this.changes > 0) {
                console.log('üßπ Ordres expir√©s nettoy√©s:', this.changes);
            }
        }
    );
}

// Fonction pour calculer le prix moyen pond√©r√©
function calculateVWAP(symbol, hours = 24) {
    return new Promise((resolve, reject) => {
        db.get(
            `SELECT 
                SUM(total_amount) / SUM(quantity) as vwap,
                COUNT(*) as trade_count
             FROM trades 
             WHERE asset_symbol = ? AND created_at > datetime('now', '-${hours} hours')`,
            [symbol],
            (err, row) => {
                if (err) reject(err);
                else resolve(row);
            }
        );
    });
}

// Nettoyer les ordres expir√©s toutes les heures
setInterval(cleanupExpiredOrders, 60 * 60 * 1000);

// ======== ROUTES ADMIN ========

// Route pour obtenir des statistiques globales (admin)
app.get('/api/admin/global-stats', (req, res) => {
    Promise.all([
        new Promise((resolve, reject) => {
            db.get('SELECT COUNT(*) as total_users FROM users', (err, row) => 
                err ? reject(err) : resolve(row));
        }),
        new Promise((resolve, reject) => {
            db.get('SELECT COUNT(*) as total_orders FROM orders', (err, row) => 
                err ? reject(err) : resolve(row));
        }),
        new Promise((resolve, reject) => {
            db.get('SELECT COUNT(*) as total_trades, SUM(total_amount) as total_volume FROM trades', (err, row) => 
                err ? reject(err) : resolve(row));
        }),
        new Promise((resolve, reject) => {
            db.all('SELECT asset_symbol, COUNT(*) as count FROM trades GROUP BY asset_symbol', (err, rows) => 
                err ? reject(err) : resolve(rows));
        })
    ]).then(([users, orders, trades, assetStats]) => {
        res.json({
            success: true,
            globalStats: {
                totalUsers: users.total_users,
                totalOrders: orders.total_orders,
                totalTrades: trades.total_trades,
                totalVolume: trades.total_volume || 0,
                assetStats: assetStats
            }
        });
    }).catch(error => {
        console.error('‚ùå Erreur stats globales:', error);
        res.status(500).json({ success: false, error: error.message });
    });
});

// ======== MIDDLEWARE DE GESTION D'ERREUR ========

// Middleware pour capturer les erreurs 404
app.use('*', (req, res) => {
    res.status(404).json({
        success: false,
        error: 'Endpoint non trouv√©',
        availableEndpoints: [
            'GET /api/test',
            'POST /api/register',
            'GET /api/balances/:address',
            'GET /api/vault-balances/:address',
            'POST /api/create-order-with-approval',
            'POST /api/orders',
            'GET /api/orderbook/:symbol',
            'POST /api/withdraw',
            'GET /api/trades/:userAddress',
            'GET /api/stats/:symbol'
        ]
    });
});

// Middleware pour capturer les erreurs g√©n√©rales
app.use((err, req, res, next) => {
    console.error('‚ùå Erreur serveur:', err);
    res.status(500).json({
        success: false,
        error: 'Erreur interne du serveur',
        message: process.env.NODE_ENV === 'development' ? err.message : 'Une erreur est survenue'
    });
});

// ======== D√âMARRAGE DU SERVEUR ========

app.listen(PORT, () => {
    console.log(`
üöÄ ====================================
   SERVEUR BACKEND D√âMARR√â
üöÄ ====================================

üìç URL: http://localhost:${PORT}
üìã API Test: http://localhost:${PORT}/api/test

‚öôÔ∏è MODE HYBRIDE ACTIV√â:
   üîí Mode Approbation: /api/create-order-with-approval (recommand√©)
   üè¶ Mode Vault: /api/orders (audit/d√©mo)

üìä ENDPOINTS PRINCIPAUX:
   GET  /api/balances/:address - Balances wallet
   GET  /api/vault-balances/:address - Balances vault  
   POST /api/withdraw - Retrait du vault
   GET  /api/orderbook/:symbol - Carnet d'ordres
   GET  /api/trades/:userAddress - Historique trades
   GET  /api/stats/:symbol - Statistiques trading

üõ°Ô∏è S√âCURIT√â:
   ‚úÖ CORS activ√©
   ‚úÖ Validation des entr√©es
   ‚úÖ Gestion d'erreurs compl√®te
   ‚úÖ Cleanup automatique

üéØ PR√äT POUR L'AUDIT!
====================================`);
});

// ======== GESTION D'ERREUR GLOBALE ========

process.on('uncaughtException', (err) => {
    console.error('‚ùå Erreur non g√©r√©e:', err);
    console.log('üîÑ Red√©marrage du serveur recommand√©');
});

process.on('unhandledRejection', (reason, promise) => {
    console.error('‚ùå Promise rejet√©e non g√©r√©e:', reason);
    console.log('üîÑ V√©rifiez les connexions async');
});

// Fonction de fermeture propre
process.on('SIGINT', () => {
    console.log('\nüõë Arr√™t du serveur demand√©...');
    db.close((err) => {
        if (err) {
            console.error('‚ùå Erreur fermeture DB:', err);
        } else {
            console.log('‚úÖ Base de donn√©es ferm√©e proprement');
        }
        process.exit(0);
    });
});

// Export pour les tests
module.exports = app;