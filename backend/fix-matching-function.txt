// Fonction de matching des ordres CORRIG√âE
async function matchOrders(assetSymbol) {
    console.log('üéØ Matching orders pour', assetSymbol);
    
    return new Promise((resolve) => {
        db.all(
            'SELECT * FROM orders WHERE asset_symbol = ? AND status = ? ORDER BY created_at ASC',
            [assetSymbol, 'pending'],
            async (err, orders) => {
                if (err) {
                    console.error('‚ùå Erreur matching:', err);
                    resolve();
                    return;
                }
                
                const buyOrders = orders.filter(o => o.order_type === 'buy').sort((a, b) => b.price - a.price);
                const sellOrders = orders.filter(o => o.order_type === 'sell').sort((a, b) => a.price - b.price);
                
                console.log('üìä Ordres √† matcher:', { 
                    buy: buyOrders.length, 
                    sell: sellOrders.length 
                });
                
                // Afficher les ordres pour debugging
                console.log('üîµ Ordres d\'achat:', buyOrders.map(o => `${o.quantity}@${o.price} (${o.user_address.slice(0,8)})`));
                console.log('üî¥ Ordres de vente:', sellOrders.map(o => `${o.quantity}@${o.price} (${o.user_address.slice(0,8)})`));
                
                for (const sellOrder of sellOrders) {
                    for (const buyOrder of buyOrders) {
                        // CONDITION CORRIG√âE: l'acheteur doit avoir assez pour acheter (quantit√© ET prix)
                        if (buyOrder.price >= sellOrder.price && buyOrder.quantity >= sellOrder.quantity) {
                            
                            console.log('üí• Match trouv√©!', {
                                buy: `${buyOrder.quantity} @ ${buyOrder.price} TRG`,
                                sell: `${sellOrder.quantity} @ ${sellOrder.price} TRG`,
                                buyer: buyOrder.user_address.slice(0,10) + '...',
                                seller: sellOrder.user_address.slice(0,10) + '...'
                            });
                            
                            try {
                                const response = await fetch('http://localhost:3001/api/execute-trade', {
                                    method: 'POST',
                                    headers: { 'Content-Type': 'application/json' },
                                    body: JSON.stringify({
                                        buyerAddress: buyOrder.user_address,
                                        sellerAddress: sellOrder.user_address,
                                        assetSymbol: assetSymbol,
                                        quantity: sellOrder.quantity, // Quantit√© du vendeur
                                        price: sellOrder.price // Prix du vendeur (plus favorable)
                                    })
                                });
                                
                                const result = await response.json();
                                
                                if (result.success) {
                                    console.log('‚úÖ Trade ex√©cut√© avec succ√®s!');
                                } else {
                                    console.log('‚ùå Erreur lors du trade:', result.error);
                                }
                                
                            } catch (error) {
                                console.error('‚ùå Erreur ex√©cution trade:', error.message);
                            }
                            
                            resolve();
                            return;
                        }
                    }
                }
                
                console.log('‚è∏Ô∏è Aucun match trouv√© pour', assetSymbol);
                resolve();
            }
        );
    });
}
