                            // DÃ©terminer la quantitÃ© Ã  Ã©changer (minimum des deux)
                            const tradeQuantity = Math.min(buyOrder.quantity, sellOrder.quantity);
                            
                            // NOUVEAU: DÃ©terminer le mode de trade (prioritÃ© au mode vault pour compatibilitÃ©)
                            const tradeMode = (buyOrder.mode === 'vault' || sellOrder.mode === 'vault') ? 'vault' : 'approval';
                            
                            console.log('ðŸ’¥ Match trouvÃ©!', {
                                buy: `${buyOrder.quantity} @ ${buyOrder.price} TRG [${buyOrder.mode}]`,
                                sell: `${sellOrder.quantity} @ ${sellOrder.price} TRG [${sellOrder.mode}]`,
                                tradeQuantity: tradeQuantity,
                                tradeMode: tradeMode,
                                type: tradeQuantity === buyOrder.quantity && tradeQuantity === sellOrder.quantity ? 'FULL' :
                                      tradeQuantity === buyOrder.quantity ? 'BUY_FILLED' :
                                      tradeQuantity === sellOrder.quantity ? 'SELL_FILLED' : 'PARTIAL'
                            });
                            
                            try {
                                // NOUVEAU: Choisir le bon endpoint selon le mode
                                const endpoint = tradeMode === 'vault' ? '/api/execute-trade' : '/api/execute-trade-approval';
                                
                                console.log(`ðŸŽ¯ Utilisation endpoint: ${endpoint} (mode: ${tradeMode})`);
                                
                                // ExÃ©cuter le trade sur la blockchain
                                const response = await fetch(`http://localhost:3001${endpoint}`, {
